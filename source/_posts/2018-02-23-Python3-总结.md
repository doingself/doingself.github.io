---
title: Python3 总结
date: 2018-02-23 14:30:50
categories:
	- Python3
tags:
	- Python3
description: Python 3.6.4
copyright: true
---

Python 有两个版本，一个是 `2.x` 版，一个是 `3.x` 版，这两个版本是不兼容的. 直接学习最新的 `Python 3.6.4`.
Python 是解释型语言，你的代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，但是慢到用户感觉不出来

# 安装

+ 去官网下载安装包
+ 如果已经安装 `Homebrew` 直接执行 `brew install Python3` 安装

## 查看

```
bogon:~ syc$ python -V
Python 2.7.10
bogon:~ syc$ python3 -V
Python 3.6.4
bogon:~ syc$
```

## 解释器
+ 官方版本的解释器 CPython (用 C 开发的)
+ Jython 是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行。

## 简单使用

终端输入 `Python3` 出现 `>>>` 即可编写 Python 代码, 输入 `exit()` 或者按 `Ctrl+d` 退出
输入 `Python3 filename.py` 运行文件

```
bogon:~ syc$ python3
Python 3.6.4 (default, Jan  6 2018, 11:51:15)
[GCC 4.2.1 Compatible Apple LLVM 9.0.0 (clang-900.0.39.2)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> 1+2-3*5
-12
>>> print("1+2-3*5=",1+2-3*5)
1+2-3*5= -12
>>> name = input("option haha->")
option haha->eee
>>> name
'eee'
>>> print(name)
eee
>>>
```

# 基本语法

Python 大小写敏感, 采用缩进式语法, `#` 表示注释, 当语句以冒号 `:` 结尾时，缩进的语句视为代码块.
按照约定俗成的管理，应该始终坚持使用4个空格的缩进. 

## 转意

```
>>> print('\\')
\
>>> print(r'\\')
\\
>>> print('''1
... 2
... 3''')
1
2
3
>>>
```

## 除法

除法 `/` 结果为浮点型, `//` 地板除法的结果为整形, 既 只取结果的整数部分

```
>>> 9/3
3.0
>>> 10//3
3
>>>
```

## 字符
计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。
最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。
最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为 `ASCII编码`
`Unicode` 把所有语言都统一到一套编码里, 如 `GB2312`

Python的字符串类型是`str`，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把`str`变为以字节为单位的`bytes` (对`bytes`类型的数据用带`b`前缀的单引号或双引号表示)
`'ABC'`和`b'ABC'`，前者是str一个字符对应若干个字节，后者是bytes每个字符都只占用一个字节。
1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。

`ord()` 函数获取字符的整数表示，`chr()` 函数把编码转换为对应的字符
以Unicode表示的 `str` 通过 `encode()` 方法可以编码为指定的 `bytes`, `bytes` 通过 `decode()` 变为 `str`

```
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
```
第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释
第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。
确保文本编辑器正在使用 `UTF-8 without BOM` 编码

### 占位符

```
>>> 'int=%d float=%f string=%s 16=%x' % (1,2.3,'str',0x1a)
'int=1 float=2.300000 string=str 16=1a'
>>> 'string={0} float={1:.2f}'.format('haha',1.234567)
'string=haha float=1.23'
```

## list 列表

list是一种有序的集合，可以随时添加和删除其中的元素。
list里面的元素的数据类型也可以不同

```
>>> arr = [0,1,2,'3a']
>>> arr[0]=9
>>> arr
[9, 1, 2, 3]
>>> len(arr)
4
>>> arr[2]
2
>>> arr[-1]
'3a'
```

`arr[-1]` 表示倒数第一个
`arr.append(4)` 添加
`arr.insert(1,5)` 添加到指定位置
`arr.pop()` 默认删除最后一个, `arr.pop(1)` 根据索引删除

## set

```
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# 有序 无重复
s = set([1,1,2,2,3,3])
print(s)

# 添加
s.add(4)
print(s)

# 根据 key 删除
s.remove(2)
print('s=',s)

s2 = set([4,5,6,7])
print('s2=',s2)

# 交集
print(s & s2)

# 并集
print(s | s2)
```

## tuple 元组

元组不可变(swift 元组可变)
只有1个元素的tuple定义时必须加一个逗号 `,` 来消除歧义 `t = (123,)`

## diction 字典(map)

```
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

dic = {'a':1, 'b':2, 'c':3}

print(dic['a'])
print(dic.get('a'))

print('aaa' in dic)
#dic['aaa'] 报错
print(dic.get('aaa')) # None
print(dic.get('aaa', 111)) # 111

# 根据 key 删除
dic.pop('c')
print(dic)
```

## 切片(类似 range)
```
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# list
arr = range(3,9)
print(arr)

arr = list(arr)
print(arr)

# 从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2
print(arr[0:3])

# 倒数第3个到倒数第1个
print(arr[-3:-1])


# 前10，每2个取一个
print(arr[:10:2])

# 所有数，每2个取一个
print(arr[::2])

# tuple
print((0,1,2,3,4,5,6,7,8)[2:6])
# str
print('abcdefg'[2:6])
```

## if

只要 `x` 是非零数值、非空字符串、非空list等，就判断为True，否则为False。
```
if x:
    print('True')
```

## for / while

```
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

print('\n for in list')

for x in ['a',2,1.23]:
	print(x)

print(r"\n for in range")

for x in range(3):
	if x == 1:
		# 结束当前循环
		continue
	print(x)

print(''' s
 while
 e''')
n = 0
while n < 4:
	if n > 2:
		# 跳出循环
		break
	print(n)
	n+=1
```

## 迭代

凡是可作用于for循环的对象都是Iterable类型. 
凡是可作用于next()函数的对象都是Iterator类型

```
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from collections import Iterable

b = isinstance('abc', Iterable)
print('str is Iterable', b)

b = isinstance([1,2,3], Iterable)
print('list is Iterable', b)

b = isinstance((1,2,3), Iterable)
print('tuple is Iterable', b)

print('\n for string')
# str
for s in 'abc':
	print(s)

print('\n for list')
# list
a = [2,4,6,8]
for v in a:
	print(v)

# enumerate函数可以把一个list变成索引-元素对
for i,v in enumerate(a):
	print(i,v)

print('\n for dictionary')
# dict
d = {'a':1, 'b':'b', 'c':3.5}

for k in d:
	print(k)

for v in d.values():
	print(v)

for k,v in d.items():
	print(k, v)
```

## 列表生成式 生成器

```
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

a = [x*x for x in range(10)]
print(a)

a = [x+x for x in range(10) if x%2==0]
print(a)


a = [i+j for i in 'abc' for j in '123']
print(a)
a = [i+'-'+j for i in 'abc' for j in '123']
print(a)
```

一边循环一边计算的机制，称为生成器：`generator`
+ 列表生成式的[]改成()，就创建了一个generator
+ 函数定义中包含yield关键字，就是一个generator

generator 遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行. 
函数是顺序执行，遇到return语句或者最后一行函数语句就返回.


```
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

g = (i for i in range(5))
print(g)

for n in g:
	print('for generator=',n)

# 函数
# 斐波拉契数列（Fibonacci）
def fib(max):
    (n, a, b) = (0, 0, 1)    
    while n < max:
        print('func=',b)
        (a, b) = (b, a + b)
        n = n + 1
    return 'done'

fib(10)

# generator
# 把 print ---> yield
def fib2(max):
    n, a, b = 0, 0, 1
    while n < max:
        yield b
        a, b = b, a + b
        n = n + 1
    return 'done'

g = fib2(10)
while True:
	try:
		n = next(g)
		print('while generator=',n)
	except Exception as e:
		print('while Exception=',e.value)
		break
```

# 函数

定义一个函数要使用 `def` 语句，依次写出`函数名`、`括号`、`括号中的参数`和`冒号:`，然后，在缩进块中编写函数体，函数的返回值用`return`语句返回。


## 空函数

```
def nonFunc():
	# pass 占位符,什么也不做
	pass
	
nonFunc()

if 1 > 2:
	# pass 占位符,什么也不做
	pass
```

## 单个返回值函数

函数执行完毕也没有`return`语句时，自动`return None`

```
def myFunc(a,b):
	if not isinstance(a, (int, float)):
		return 'type error'
	elif not isinstance(b, (int, float)):
		return TypeError('type error')
	elif a > b:
		return True
	else:
		return False

# 把函数名赋给一个变量，相当于给这个函数起了一个“别名”
a = myFunc
print(a(1,2))

print(myFunc(4,2))
print(myFunc('a',2))
print(myFunc(4,'a'))
```

## 多个返回值函数

返回一个tuple可以省略括号
默认参数必须指向不变对象

```
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import math

# 默认参数必须指向不变对象
def move(x,y, step = 0, angle = 0):
	newx = x + step * math.cos(angle)
	newy = y + step * math.sin(angle)
	return newx, newy

x, y = move(1, 1, 2, 45*180)
print(x, y)

# step=2
x, y = move(1, 1, 2)
print(x, y)

# angle = 2
x, y = move(1, 1, angle = 2)
print(x, y)
```

## 可变参数

+ 参数前加 `*` 可变参数在函数调用时自动组装为一个tuple
```
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

def printParams(*pars):
	for par in pars:
		print(par)

printParams(1,'a',3.5)
```

+ 参数前加 `**` 关键字参数在函数调用时自动组装为一个dict
```
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

def printParams(**pars):
	print(pars)

printParams(a=1,b='a',c=3.5)

d = {'a':1, 'b': 'a', 'c':3.5}
printParams(**d)
```

+ `*,` 后面的参数被视为命名关键字参数, 限制关键字参数的名字
```
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# 只接收 b,c
def printParams(a, *, b, c):
	print(a,b,c)

printParams(1, b='a', c=0.3)
```

+ 混合使用
```
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

def printParams(a, b='b' , *c, **d):
	print(a,b,c,d)

printParams(1, 2, 0.3,0.4, d1=1,d2='d2')
# list or tuple
arr = (1,2,3)
dic = {'d1':1,'d2':2}
printParams(1, 2, *arr, **dic)

def printParams2(a, b='b' , *,c, **d):
	print(a,b,c,d)

printParams2(1, 2, c=0.4, d1=1,d2='d2')
```

## 高阶函数

既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数
```
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from functools import reduce

# map
# x * x
def f(x):
	return x*x
r = map(f, [1,2,3,4,5])
print(r)
l = list(r)
print(l)

# int ---> str
r = map(str, [1,2,3,4,5])
print(list(r))

# reduce 计算
# sum
def f2(a,b):
	return a+b

r = reduce(f2,[1,2,3,4,5])
print(r)

# filter 过滤
def f3(x):
	b = x % 2 == 0
	return b

r = filter(f3,[1,2,3,4,5])
print(list(r))

# sorted 排序
r = sorted([1,5,4,2,3])
print(r)

# 忽略大小写
# key 函数来实现自定义的排序
# reverse 反向排序
r = sorted(['Sss','Aaa','sss','aaa'], key = str.lower, reverse = True)
print(r)
```

## 闭包
TODO: 思想和 swift 一致

## 匿名函数

关键字 `lambda` 表示匿名函数，冒号前面的`x`表示函数参数
用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突
匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果
由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数

```
f = lambda x: x * x
v = f(3)
print(v)

m = map(lambda x: x*x, [1,2,3,4])
print(list(m))

def f(x):
	return lambda: x + x
v = f(3)
print(v)
print(v())
```

## 装饰器(类似触发器/过滤器)

在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。


---

参考

+ https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000